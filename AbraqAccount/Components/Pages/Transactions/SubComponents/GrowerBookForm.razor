@using AbraqAccount.Models
@using AbraqAccount.Services.Interfaces
@using AbraqAccount.Components.Common
@inject IGeneralEntryService GeneralEntryService
@inject ISettingsService SettingsService

<div class="transaction-form">
    <div class="form-header">
        <h3 class="form-title">Grower Book - @(string.IsNullOrEmpty(VoucherNo) ? "Add" : "Edit")</h3>
    </div>

    <EditForm Model="@item" OnValidSubmit="SubmitForm">
        <DataAnnotationsValidator />
        
        <div class="row g-3">
            <!-- Entry For & Transaction Date -->
            <div class="col-md-6">
                <label class="form-label">Entry For</label>
                <InputSelect @bind-Value="item.EntryForId" class="form-select" @oninput="OnEntryForChanged">
                    <option value="0">Select Entry For</option>
                    @if (entryProfiles != null)
                    {
                        foreach (var p in entryProfiles)
                        {
                            <option value="@p.Id">@p.Name</option>
                        }
                    }
                </InputSelect>
            </div>
            
            <div class="col-md-6">
                <label class="form-label">Transaction Date <span class="text-danger">*</span></label>
                <InputDate @bind-Value="item.EntryDate" class="form-control" />
            </div>

            <!-- Amount & Unit -->
            <div class="col-md-6">
                <label class="form-label">Amount <span class="text-danger">*</span></label>
                <InputNumber @bind-Value="item.Amount" class="form-control" min="0.01" step="0.01" />
            </div>

            <div class="col-md-6">
                <label class="form-label">Unit <span class="text-danger">*</span></label>
                <div class="input-group">
                    <InputSelect @bind-Value="item.Unit" class="form-select">
                        <option value="">Select Unit</option>
                        @if (units != null)
                        {
                            foreach (var u in units)
                            {
                                <option value="@u">@u</option>
                            }
                        }
                    </InputSelect>
                </div>
            </div>

            <!-- Grower Credit & Debit -->
            <div class="col-md-6">
                <AccountSearch Label="Grower Credit *" 
                              SearchFunc="@(term => SearchCreditAccounts(term))" 
                              OnAccountSelected="@(a => { item.CreditAccountId = a.Id; item.CreditAccountType = "BankMaster"; creditAccountName = a.Name; })"
                              InitialValue="@creditAccountName"
                              Required="true"
                              Disabled="@(item.EntryForId == null || item.EntryForId == 0)"
                              CssClass="@(item.CreditAccountId == 0 ? "is-invalid" : "")" />
            </div>

            <div class="col-md-6">
                <AccountSearch Label="Grower Debit *" 
                              SearchFunc="@(term => SearchDebitAccounts(term))" 
                              OnAccountSelected="@(a => { item.DebitAccountId = a.Id; item.DebitAccountType = "BankMaster"; debitAccountName = a.Name; })"
                              InitialValue="@debitAccountName"
                              Required="true"
                              Disabled="@(item.EntryForId == null || item.EntryForId == 0)"
                              CssClass="@(item.DebitAccountId == 0 ? "is-invalid" : "")" />
            </div>

            <!-- Narration -->
            <div class="col-12">
                <label class="form-label">Particular</label>
                <InputTextArea @bind-Value="item.Narration" class="form-control" rows="2" placeholder="Enter Particular" />
            </div>
            
            @if (!string.IsNullOrEmpty(errorMessage))
            {
                <div class="col-12">
                    <div class="alert alert-danger">@errorMessage</div>
                </div>
            }

            <!-- Buttons -->
            <div class="col-12 d-flex justify-content-end gap-2 mt-4">
                 <button type="submit" class="btn btn-primary" disabled="@isSubmitting">
                    @if (isSubmitting)
                    {
                        <span class="spinner-border spinner-border-sm me-1"></span>
                    }
                    @(string.IsNullOrEmpty(VoucherNo) ? "Save" : "Update")
                </button>
                <button type="button" class="btn btn-secondary" @onclick="Cancel">Cancel</button>
            </div>
        </div>
    </EditForm>
</div>

@code {
    [Parameter] public string? VoucherNo { get; set; }
    [Parameter] public EventCallback OnSaved { get; set; } // If used as a component
    [Inject] public NavigationManager Navigation { get; set; } = default!;

    private GeneralEntry item = new() { EntryDate = DateTime.Today, Type = "GrowerBook" };
    private IEnumerable<LookupItem>? entryProfiles;
    private List<string> units = new();
    private string creditAccountName = "";
    private string debitAccountName = "";
    private bool isSubmitting;
    private string? errorMessage;

    protected override async Task OnInitializedAsync()
    {
        // Load Entry Profiles relevant to Grower Book if any, or general ones
        entryProfiles = await GeneralEntryService.GetEntryProfilesAsync("GrowerBook");
        units = await GeneralEntryService.GetUnitNamesAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!string.IsNullOrEmpty(VoucherNo))
        {
            var entries = await GeneralEntryService.GetVoucherEntriesAsync(VoucherNo);
            if (entries.Any())
            {
                var first = entries.First();
                // Map to item for editing
                item = first;
                // Note: Double entry logic might require adjusting how we load credit/debit 
                // but GeneralEntry usually stores them normalized or we pick the primary one.
                // Assuming standard structure where one entry represents the row.
                
                // Manually populate the local name fields since the property is read-only (computed)
                // We trust the computed property for initialization
                creditAccountName = item.CreditAccountName;
                debitAccountName = item.DebitAccountName;
            }
        }
        else
        {
             item = new GeneralEntry { EntryDate = DateTime.Today, Type = "GrowerBook" };
             creditAccountName = "";
             debitAccountName = "";
             
             if (units.Any()) item.Unit = units.First();
        }
    }

    private async Task<IEnumerable<LookupItem>> SearchCreditAccounts(string term)
    {
        // Specific search for Grower Book - Credit Side
        return await GeneralEntryService.GetGrowerAccountsAsync(term, "GrowerBook", "Credit", item.EntryForId);
    }

    private async Task<IEnumerable<LookupItem>> SearchDebitAccounts(string term)
    {
        // Specific search for Grower Book - Debit Side
        return await GeneralEntryService.GetGrowerAccountsAsync(term, "GrowerBook", "Debit", item.EntryForId);
    }

    private void OnEntryForChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int profileId) && profileId > 0)
        {
            var profile = entryProfiles?.FirstOrDefault(p => p.Id == profileId);
            item.EntryForName = profile?.Name;
            item.EntryForId = profileId; // Ensure it's set
        }
        else
        {
            item.EntryForId = null;
            item.EntryForName = null;
            
            // Clear selections if no profile
            item.DebitAccountId = 0;
            debitAccountName = "";
            item.CreditAccountId = 0;
            creditAccountName = "";
        }
    }

    public async Task SubmitForm()
    {
        errorMessage = null;
        if (item.EntryForId == null || item.EntryForId == 0)
        {
            errorMessage = "Please select 'Entry For' profile.";
            return;
        }
        if (item.CreditAccountId == 0 || item.DebitAccountId == 0 || item.Amount <= 0)
        {
            errorMessage = "Please fill all required fields.";
            return;
        }

        isSubmitting = true;
        (bool success, string message) result;

        if (!string.IsNullOrEmpty(VoucherNo))
        {
             result = await GeneralEntryService.UpdateGrowerBookEntryAsync(item, "admin");
        }
        else
        {
             result = await GeneralEntryService.CreateGrowerBookEntryAsync(item, "admin");
        }
        
        isSubmitting = false;

        if (result.success)
        {
            if (OnSaved.HasDelegate)
            {
                await OnSaved.InvokeAsync();
            }
            else
            {
                // Navigate back to list or refresh
                Navigation.NavigateTo("grower-book/index"); 
            }
        }
        else
        {
            errorMessage = result.message;
        }
    }

    private void Cancel()
    {
        // If we are in a modal/component logic, delegate back or navigate
        if (OnSaved.HasDelegate)
        {
             // For cancel, we might want a separate OnCancel or just assume standard flow
             // But if we just want to go back:
             // Since OnSaved implies "done with form", we can misuse it or better just navigate if not handled.
             // However, specific requirement is "Redirect properly to their list".
        }
        Navigation.NavigateTo("grower-book/index"); 
    }
}
